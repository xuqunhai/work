获取 Git 仓库
记录每次更新到仓库
跳过使用暂存区域
忽略文件
移除文件
文件重命名
Git 内部原理
查看提交历史
撤消操作
远程仓库的使用
打标签
Git 别名
Git 分支 - 分支管理
git checkout知识点
删除远程分支
Git 分支 - 变基
Git 工具 - 高级合并
git diff
Git 工具 - 贮藏与清理
清理工作目录

-----------------------------------------------------------------------------------------

获取 Git 仓库

$ git init
该命令将创建一个名为 .git 的子目录，
这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。

“master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，
“origin” 是当你运行 git clone 时默认的远程仓库名字。
如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。

-----------------------------------------------------------------------------------------

记录每次更新到仓库

文件都不外乎这两种状态：已跟踪 或 未跟踪。
已跟踪的文件就是 Git 已经知道的文件。
用 git status 命令查看哪些文件处于什么状态。

状态简览
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt

新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。
输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。
xuqunhai@xuqunhaideMacBook-Pro work % git status -s
AM README // 文件add后作了再次修改

-----------------------------------------------------------------------------------------

忽略文件

$ cat .gitignore
*.[oa] // 忽略所有以 .o 或 .a 结尾的文件。这类对象文件和存档文件都是编译过程中出现的。
*~     // 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。
可能还需要忽略 log，tmp 或者 pid 目录

要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯
文件 .gitignore 的格式规范如下：
所有空行或者以 # 开头的行都会被 Git 忽略。
可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。
匹配模式可以以（/）开头防止递归。
匹配模式可以以（/）结尾指定目录。
要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。

使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。

# 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a
# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO
# 忽略任何目录下名为 build 的文件夹
build/
# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf

-----------------------------------------------------------------------------------------

跳过使用暂存区域

只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：
因为 -a 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。

-----------------------------------------------------------------------------------------

移除文件

想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 
当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 
为达到这一目的，使用 --cached 选项：
$ git rm --cached README

-----------------------------------------------------------------------------------------

重命名文件

$ git mv file_from file_to
相当于运行了下面三条命令：
$ mv README.md README
$ git rm README.md
$ git add README

-----------------------------------------------------------------------------------------

Git 内部原理

  内容寻址文件系统，
  版本控制系统
  用户界面。
底层命令与上层命令
底层命令得以让你窥探 Git 内部的工作机制，
也有助于说明 Git 是如何完成工作的，以及它为何如此运作，
多数底层命令并不面向最终用户。

执行 git init 时，Git 会创建一个 .git 目录。
新初始化的 .git 目录的典型结构如下：
$ ls -F1
config -- 包含项目特有的配置选项。
description
HEAD
hooks/ -- 包含客户端或服务端的钩子脚本
info/
objects/
refs/

四个条目很重要：HEAD 文件、（尚待创建的）index 文件，和 objects 目录、refs 目录。
它们都是 Git 的核心组成部分。
objects 目录存储所有数据内容；
refs 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针；
HEAD 文件指向目前被检出的分支；
index 文件保存暂存区信息。

-----------------------------------------------------------------------------------------

查看提交历史
限制 git log 输出的选项
选项	说明
-<n> 仅显示最近的 n 条提交。
--since, --after 仅显示指定时间之后的提交。
--until, --before 仅显示指定时间之前的提交。
--author 仅显示作者匹配指定字符串的提交。
--committer 仅显示提交者匹配指定字符串的提交。
--grep 仅显示提交说明中包含指定字符串的提交。
-S 仅显示添加或删除内容匹配指定字符串的提交。

选项是 -p 或 --patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 
你也可以限制显示的日志条目数量，例如使用 -2 选项来只显示最近的两次提交：
$ git log -p -2
进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候

在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 
$ git log --stat

将每个提交放在一行显示，在浏览大量的提交时非常有用
$ git log --pretty=oneline

git log --pretty=format:"%h - %an, %ar : %s" --graph
git log --pretty=format:"%h - %an, %ar : %s"
632ba65 - xuqunhai, 7 hours ago : vue2+vite learning
2dd5091 - xuqunhai, 4 weeks ago : vue3管理后台框架+登陆demo
0004504 - xuqunhai, 7 weeks ago : 被删前端监控参考补充2
e68e9aa - xuqunhai, 7 weeks ago : 被删前端监控参考补充
8f6b89c - xuqunhai, 7 weeks ago : 前端性能监控参考

%an - 作者名字
%cn - 提交者的名字
当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 

git log --name-only  // 仅在提交信息后显示已修改的文件清单。
git log --name-status // 显示新增、修改、删除的文件清单。

列出最近两周的所有提交：
$ git log --since=2.weeks
该命令可用的格式十分丰富——可以是类似 "2008-01-15" 的具体的某一天，也可以是类似 "2 years 1 day 3 minutes ago" 的相对日期。
还可以过滤出匹配指定条件的提交。 用 --author 选项显示指定作者的提交

实际的例子，如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令：
记录中可能有为数不少的合并提交，它们所包含的信息通常并不多。 为了避免显示的合并提交弄乱历史记录，可以为 log 加上 --no-merges 选项。
$ git log --pretty="%h - %s" --author='Junio C Hamano' --since="2008-10-01" --before="2008-11-01" --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are in use
acd3b9e - Enhance hold_lock_file_for_{update,append}() API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
51a94af - Fix "checkout --track -b newbranch" on detached HEAD
b0ad11e - pull: allow "git pull origin $something:$current_branch" into an unborn branch

git log --no-merges --author="Pattern" --name-only --pretty=format:"" | sort -u
https://stackoverflow.com/questions/6349139/can-i-get-git-to-tell-me-all-the-files-one-user-has-modified

为什么两条线上的开发会触碰同一片代码有时会很有用。即冲突文件是哪两次commit？
$ git log --oneline --left-right --merge
如果你运行命令时用 -p 选项代替，你会得到所有冲突文件的区别。 快速获得你需要帮助理解为什么发生冲突的上下文，以及如何聪明地解决它，这会 非常 有用。

查看冲突是如何解决的
$ git log --cc -p -1

xuqunhai519
查看某人一段时间内提交所有文件
git log --since=2022-07-20 --until=2022-07-23 --author='ex-fangtao001' --pretty=tformat: --numstat
回退到某个commit
git reset xxxxxx
去掉未提交里不是某人修改的文件，剩下的就是某人某段时间所有改动


-----------------------------------------------------------------------------------------

mac下解决gitk模糊完整教程
https://blog.csdn.net/ieayoio/article/details/79442531
Git for windows 中文乱码解决方案
https://segmentfault.com/a/1190000000578037

-----------------------------------------------------------------------------------------

撤消操作
提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
最终你只会有一个提交——第二次提交将代替第一次提交的结果。
取消暂存的文件
  (use "git reset HEAD <file>..." to unstage)
撤消对文件的修改-将它还原成上次提交时的样子
  (use "git checkout -- <file>..." to discard changes in working directory)
记住，在 Git 中任何 已提交 的东西几乎总是可以恢复的。 
甚至那些被删除的分支中的提交或使用 --amend 选项覆盖的提交也可以恢复 （阅读 数据恢复 了解数据恢复）。 
然而，任何你未提交的东西丢失后很可能再也找不到了。

-----------------------------------------------------------------------------------------

远程仓库的使用
git remote 命令 - 查看你已经配置的远程仓库服务器
如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：
　　　　1.git remote 不带参数，列出已经存在的远程分支
　　　　2.git remote -v | --verbose 列出详细信息，在每一个名字后面列出其远程url，此时， -v 选项(译注:此为 –verbose 的简写,取首字母),显示对应的克隆地址。
　　　　3.git remote add url   添加一个远程仓库

新建一个git仓库并与远程关联 - 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：
git remote add origin https://gitee.com/isevenluo/test.git

如果远端仓库地址地址更改了，我这可以这样去更新
git remote set-url new_rep http://192.168.3.250/wangshengxing/test.git

修改origin远程仓库的push地址
git remote set-url --push origin https://gitee.com/SillyCuckoo/code-repository.git
fetch和push地址已经不相同了，这样我就可以实现从一个库fetch更新当前项目，向另一个库push提交最新代码；
开发场景：
存在一个"公共主库"，最新代码都是从"公共主库"拉取，我们fork了一个"公共主库的项目"到自己的账号下为我们"自己拥有的远程仓库"，
我们以后提交代码前都是从"公共主库"拉取最新代码。
我们却只能向"自己拥有的远程仓库"推送代码，
只有在经过项目组其他成员的review后我们才能从"自己拥有的远程仓库"向"公共仓库"提交合并请求，实现最后的代码合并。

要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 
这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 
从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。

git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。
必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。
它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。
即只更新本地数据库，移动 origin/master 指针到更新之后的位置。
git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。
相当于git fetch 和 git merge

远程仓库的重命名与移除
$ git remote rename pb paul
移除一个远程仓库
$ git remote remove paul
所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。

-----------------------------------------------------------------------------------------

打标签
https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE

-----------------------------------------------------------------------------------------

Git 别名
https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D
 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：
$ git config --global alias.unstage 'reset HEAD --'
这会使下面的两个命令等价：
$ git unstage fileA
$ git reset HEAD -- fileA

-----------------------------------------------------------------------------------------

Git 分支 - 分支管理
git branch  如果不加任何参数运行它，会得到当前所有分支的一个列表
分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）

查看每一个分支的最后一次提交，可以运行 git branch -v 命令：

如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged
查看所有包含未合并工作的分支，可以运行 git branch --no-merged
xuqunhai519
查看远程未合并分支 git branch -r --no-merged
在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。

尚未合并到 master 分支的有哪些？
$ git checkout testing
$ git branch --no-merged master

-----------------------------------------------------------------------------------------

git checkout知识点
git checkout branchname （切换本地分支）
git checkout -b 本地分支名 origin/远程分支名
该命令可以将远程仓库里指定的分支拉取到本地，并在本地创建一个分支与指定远程仓库分支关联起来。并切换到新建的本地分支中。
git checkout .   放弃所有工作区的修改
git checkout -- filename 放弃对指定文件的暂存区修改
git checkout -f 放弃工作区和暂存区的所有修改

$ git checkout --conflict=diff3 hello.rb
传递给 --conflict 参数 diff3 或 merge（默认选项）。 
如果传给它 diff3，Git 会使用一个略微不同版本的冲突标记： 
不仅仅只给你 “ours” 和 “theirs” 版本，同时也会有 “base” 版本在中间来给你更多的上下文。
git checkout 命令也可以使用 --ours 和 --theirs 选项，这是一种无需合并的快速方式，你可以选择留下一边的修改而丢弃掉另一边修改。
当有二进制文件冲突时这可能会特别有用；

当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 
然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。
$ git checkout --track origin/serverfix
如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：
$ git checkout -b sf origin/serverfix
设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，
你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。
$ git branch -u origin/serverfix

使用git branch new_branch来创建新的分支。一旦创建完成，就可以继续使用git checkout new_branch来切换到这个新创建好的分支。
此外，git checkout命令还接受一个 -b 参数，作为创建分支并立刻切换到新分支这一系列操作的快捷方式。

checkout一个远程分支
为了能够checkout出某一个远程仓库的分支，我们需要先fetch那个仓库的内容。
git fetch --all
之后在较新版本的Git中，你就可以像checkout本地分支一样checkout出这个远程分支了。
git checkout ＜remotebranch＞
对于比较老的Git版本，则需要先基于remote中的指定远程分支创建一个新分支。
git checkout -b ＜remotebranch＞ origin/＜remotebranch＞
此外，你还可以checkout一个本地分支，然后将其硬重置为远程分支的最新commit。
git checkout -b ＜branchname＞
git reset --hard origin/＜branchname＞

-----------------------------------------------------------------------------------------

删除远程分支
$ git push origin --delete serverfix
基本上这个命令做的只是从服务器上移除这个指针。
Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。

-----------------------------------------------------------------------------------------

Git 分支 - 变基
整合分支最容易的方法是 merge 命令。 
它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。

-----------------------------------------------------------------------------------------

Git 工具 - 高级合并
合并冲突
Automatic merge failed; fix conflicts and then commit the result.
如何摆脱这个情况？现在有几个选项。

中断一次合并
可能不想处理冲突这种情况，完全可以通过 git merge --abort 来简单地退出合并。
会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。

出于某些原因你想要重来一次，也可以运行 git reset --hard HEAD 回到上一次提交的状态。
请牢记此时任何未提交的工作都会丢失，所以请确认你不需要保留任何改动。

忽略空白
使用 -Xignore-all-space 或 -Xignore-space-change 选项。
第一个选项在比较行时 完全忽略 空白修改，第二个选项将一个空白符与多个连续的空白字符视作等价的。
$ git merge -Xignore-space-change whitespace
如果你的团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，这会是一个救命稻草。

手动文件再合并
这比使用 ignore-space-change 选项要更好，因为在合并前真正地修复了空白修改而不是简单地忽略它们。
https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6

-----------------------------------------------------------------------------------------

git diff 来比较将要提交作为合并结果的工作目录与其中任意一个阶段的文件差异。
看看合并引入了什么，可以运行 git diff --ours
查看合并的结果与他们那边有什么不同，可以运行 git diff --theirs
通过 git diff --base 来查看文件在两边是如何改动的。

-----------------------------------------------------------------------------------------

Git 工具 - 贮藏与清理
贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 
而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。
现在想要切换分支，但是还不想要提交之前的工作；所以贮藏修改。 将新的贮藏推送到栈上，
运行 git stash 或 git stash push：
要查看贮藏的东西，可以使用 git stash list：
如果想要应用其中一个更旧的贮藏，可以通过名字指定它，像这样：git stash apply stash@{2}。 如果不指定一个贮藏，Git 认为指定的是最近的贮藏：

在新分支轻松恢复贮藏工作并继续工作的一个很不错的途径。
可以运行 git stash branch <new branchname> 以你指定的分支名创建一个新分支，检出贮藏工作时所在的提交，重新在那应用工作，然后在应用成功后丢弃贮藏：
运行 git stash pop 来应用贮藏然后立即从栈上扔掉它。

默认情况下，git stash 只会贮藏已修改和暂存的 已跟踪 文件。 如果指定 --include-untracked 或 -u 选项，Git 也会贮藏任何未跟踪文件。
然而，在贮藏中包含未跟踪的文件仍然不会包含明确 忽略 的文件。 要额外包含忽略的文件，请使用 --all 或 -a 选项。

-----------------------------------------------------------------------------------------

清理工作目录
清理工作目录有一些常见的原因，比如说为了移除由合并或外部工具生成的东西， 或是为了运行一个干净的构建而移除之前构建的残留。
你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。
一个更安全的选项是运行 git stash --all 来移除每一样东西并存放在栈中。
默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 任何与 .gitignore 或其他忽略文件中的模式匹配的文件都不会被移除。 
如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 .o 文件， 可以给 clean 命令增加一个 -x 选项。

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------