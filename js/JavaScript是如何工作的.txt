JavaScript引擎
执行 JavaScript 代码的程序或解释器

在Chrome和Node.js中使用V8引擎
V8 将 JavaScript 代码转换成更高效的机器码，而不是使用解释器。
V8引擎由两个主要部件组成:
emory Heap(内存堆) — 内存分配地址的地方
Call Stack(调用堆栈) — 代码执行的地方

浏览器提供 API 称为 Web API，比如说 DOM、AJAX、setTimeout等等。
还拥有事件循环和回调队列。

JavaScript是一种单线程编程语言，
这意味着它只有一个调用堆栈。
因此，它一次只能做一件事。
调用栈是一种数据结构，它记录了我们在程序中的位置。
运行到一个函数，它就会将其放置到栈顶，
当从这个函数返回的时候，就会将这个函数从栈顶弹出

"堆栈溢出"，
当你达到调用栈最大的大小的时候就会发生这种情况，而且这相当容易发生，
特别是在你写递归的时候却没有全方位的测试它。

怎样才能在不阻塞UI和不使浏览器失去响应的情况下执行大量代码呢?
解决方案是异步回调。

在 V8 的 5.9 版本出来之前，V8 引擎使用了两个编译器：
full-codegen — 一个简单和非常快的编译器，产生简单和相对较慢的机器码。
Crankshaft — 一种更复杂（Just-In-Time）的优化编译器，生成高度优化的代码。

V8 引擎也在内部使用多个线程：
主线程执行你所期望的操作：获取代码、编译代码并执行它
还有一个单独的线程用于编译，因此主线程可以在前者优化代码的同时继续执行
一个 Profiler 线程，它会告诉运行时我们花了很多时间，让 Crankshaft 可以优化它们
一些线程处理垃圾收集器

当第一次执行 JavaScript 代码时，
V8 利用 full-codegen 编译器，直接将解析的 JavaScript 翻译成机器代码而不进行任何转换。
这使得它可以非常快速地开始执行机器代码。请注意，V8 不使用中间字节码，从而不需要解释器。
当代码已经运行一段时间后，分析线程已经收集了足够的数据来判断应该优化哪个方法。
接下来，Crankshaft  从另一个线程开始优化。
它将 JavaScript 抽象语法树转换为被称为 Hydrogen 的高级静态单分配（SSA）表示，并尝试优化 Hydrogen 图

第一个优化是提前内联尽可能多的代码。
内联是用被调用函数的主体替换调用点（调用函数的代码行）的过程。
如执行函数f1时会把f1函数执行体关联上。

JavaScript也是一种动态编程语言，这意味着实例化后可以在对象中添加或删除属性。
JavaScript 解释器使用类似字典的结构（基于哈希函数）来存储对象属性值在内存中的位置，
使得在检索属性的值比在 Java 或 C＃ 等非动态编程语言中的计算成本更高。
由于使用字典查找内存中对象属性的位置效率非常低，因此 V8 使用了不同的方法：隐藏类。
隐藏类与 Java 等语言中使用的固定对象（类）的工作方式类似，只是它们是在运行时创建的。

function Point(x,y){
    this.x=x;
    this.y=y;
}
var p1=new Point(1,2)
一旦 “new Point（1，2）” 调用发生，V8 将创建一个名为 “C0” 的隐藏类。
一旦第一个语句“this.x = x”被执行（在“Point”函数内），V8 将创建一个名为 “C1” 的第二个隐藏类，
“C1”描述了可以找到属性 x 的存储器中的位置（相对于对象指针）。
“x”存储在偏移0处，这意味着当将存储器中的 point 对象视为连续缓冲区时，第一偏移将对应于属性 “x”。 
将属性 “x” 添加到 point 对象，则隐藏类应从 “C0” 切换到 “C1”。
当语句 “this.y = y” 被执行时，会重复同样的过程:
一个名为“C2”的新隐藏类会被创建，
如果将一个属性 “y” 添加到一个 Point 对象,point 对象的隐藏类更新为“C2”。

隐藏类转换取决于将属性添加到对象的顺序。
每次将新属性添加到对象时，旧的隐藏类都会更新为指向新隐藏类的转换路径。
对于“p1”，首先添加属性“a”，然后添加属性“b”。
然而，“p2”首先分配“b”，然后是“a”。
由于不同的转换路径，“p1”和“p2”以不同的隐藏类别结束。
在这种情况下，以相同的顺序初始化动态属性好得多，以便隐藏的类可以被重用。


内联缓存
V8利用了另一种优化动态类型语言的技术，称为内联缓存。
对同一方法的重复调用往往发生在同一类型的对象上
如果 V8 能够很好地预测传递给方法的对象的类型，
它就可以绕过如何访问对象属性的过程，而是使用从以前的查找到对象的隐藏类的存储信息。
在同一个隐藏类的两次成功的调用之后，
V8 省略了隐藏类的查找，并简单地将该属性的偏移量添加到对象指针本身。
对于该方法的所有下一次调用，
V8 引擎都假定隐藏的类没有更改，并使用从以前的查找存储的偏移量直接跳转到特定属性的内存地址。
这大大提高了执行速度。
内联缓存也是为什么相同类型的对象共享隐藏类非常重要的原因。
两个对象基本相同，但是“a”和“b”属性的创建顺序不同,V8将无法使用内联缓存.



编译成机器码
一旦 Hydrogen 图被优化，Crankshaft 将其降低到称为 Lithium 的较低级表示。
寄存器分配往往发生在这个级别。
最后，Lithium 被编译成机器码。
然后就是 OSR ：on-stack replacement（堆栈替换）。
V8 不只是缓慢执行堆栈替换，并再次开始优化。
相反，它会转换我们拥有的所有上下文（堆栈，寄存器），以便在执行过程中切换到优化版本上。



垃圾收集
V8采用传统的 mark-and-sweep 算法 来清理旧一代。 标记阶段应该停止JavaScript执行。 
为了控制GC成本并使执行更稳定，V8使用增量标记:
不是遍历整个堆，尝试标记每个可能的对象，
它只是遍历堆的一部分，然后恢复正常执行。
下一个GC停止将从上一个堆行走停止的位置继续.




如何编写优化的 JavaScript
始终以相同的顺序实例化对象属性，以便可以共享隐藏的类和随后优化的代码。
因为在实例化之后向对象添加属性将强制执行隐藏的类更改，并降低之前隐藏类所优化的所有方法的执行速度，所以在其构造函数中分配所有对象的属性。
重复执行相同方法的代码将比仅执行一次的多个不同方法（由于内联缓存）的代码运行得更快。
避免稀疏数组，这种数组中的元素访问开销较高。
尽量避免预分配大数组。最好是按需增长。
不要删除数组中的元素，这会使键值变得稀疏。
尽可能使用 31 位有符号数字，如果一个数值大于 31 位，V8会将该数字装箱，把它变成一个双精度数，并创建一个新的对象来存放该数字。







JavaScript如何工作:内存管理+如何处理4个常见的内存泄漏
像 C 这样的编程语言，具有低级内存管理原语，如malloc()和free()。
开发人员使用这些原语显式地对操作系统的内存进行分配和释放。
而JavaScript在创建对象(对象、字符串等)时会为它们分配内存，不再使用对时会“自动”释放内存
这个过程称为垃圾收集。
这种看“自动”似释放资源的的特性是造成混乱的根源,自动内存管理存在一些问题(例如垃圾收集器中的bug或实现限制等).

内存生命周期中的每一个阶段:
分配内存
 —  内存是由操作系统分配的，它允许您的程序使用它。在低级语言(例如C语言)中，这是一个开发人员需要自己处理的显式执行的操作。然而，在高级语言中，系统会自动为你分配内在。
使用内存
 — 这是程序实际使用之前分配的内存，在代码中使用分配的变量时，就会发生读和写操作。
释放内存
 — 释放所有不再使用的内存,使之成为自由内存,并可以被重利用。与分配内存操作一样,这一操作在低级语言中也是需要显式地执行。


内存是什么以及它是如何工作的。
硬件层面上，计算机内存由大量的触发器缓存的。
每个触发器包含几个晶体管，能够存储一位，单个触发器都可以通过唯一标识符寻址，因此我们可以读取和覆盖它们。

作为人类，我们并不擅长用比特来思考和计算，
所以我们把它们组织成更大的组，这些组一起可以用来表示数字。
8位称为1字节。除了字节，还有字(有时是16位，有时是32位)。

在编译代码时，编译器可以检查基本数据类型，并提前计算它们需要多少内存。
然后将所需的大小分配给调用堆栈空间中的程序，分配这些变量的空间称为堆栈空间。
因为当调用函数时，它们的内存将被添加到现有内存之上，
当它们终止时，它们按照后进先出（LIFO）顺序被移除。

编译器知道每个变量的确切内存地址。
每当我们写入变量 n 时，它就会在内部被转换成类似“内存地址4127963”这样的信息。



动态分配
在编译时,编译器不知道数组需要使用多少内存,因为这是由用户提供的值决定的。
程序需要在运行时显式地向操作系统请求适当的空间,这个内存是从堆空间分配的。

静态内存分配	       动态内存分配
大小必须在编译时知道     大小不需要在编译时知道
在编译时执行            在运行时执行
分配给堆栈	            分配给堆
FILO (先进后出)	        没有特定的分配顺序



垃圾收集算法
引用计数垃圾收集算法
如果没有指向对象的引用，则认为该对象是“垃圾可回收的”
当涉及到循环时,会有一个限制。
引用计数算法认为,由于每个对象至少被引用一次,所以它们都不能被垃圾收集。

标记-清除(Mark-and-sweep)算法
这个算法比上一个算法要好,因为“一个对象没有被引用”就意味着这个对象无法访问。
垃圾收集器构建一个“根”列表,用于保存引用的全局变量。
在JavaScript中,“window”对象是一个可作为根节点的全局变量。
然后，算法检查所有根及其子节点，并将它们标记为活动的(这意味着它们不是垃圾)。
任何根不能到达的地方都将被标记为垃圾。
最后，垃圾收集器释放所有未标记为活动的内存块，并将该内存返回给操作系统。
循环不再是问题,尽管对象之间存在引用,但它们对于根节点来说是不可达的。

看看以下场景,即使有不可访问的引用可供收集，收集器也不会声明这些引用:
分配一组相当大的内在。
这些元素中的大多数(或全部)被标记为不可访问(假设引用指向一个不再需要的缓存)。
不再进一步的分配


内存泄漏是什么?
不再被应用程序所需要的内存,出于某种原因,它不会返回到操作系统或空闲内存池中。

四种常见的内存泄漏

1.全局变量
function foo(arg) {
    bar = "some text";
}
如果bar在foo函数的作用域内对一个变量进行引用,却忘记使用var来声明它,那么将创建一个意想不到的全局变量。
在这个例子中,遗漏一个简单的字符串不会造成太大的危害,但这肯定会很糟。

创建一个意料之外的全局变量的另一种方法是使用this:
function foo() {
    this.var1 = "potential accidental global";
}
// Foo自己调用，它指向全局对象(window)，而不是未定义。
foo();

可以在JavaScript文件的开头通过添加“use strict”来避免这一切，
它将开启一个更严格的JavaScript解析模式，以防止意外创建全局变量。
如果你必须使用一个全局变量来存储大量数据,
那么请确保将其指定为null,或者在完成后将其重新赋值。


2.被遗忘的定时器和回调
一些框架或库,比如JQuery,会在处置节点之前自动删除监听器(在使用它们特定的API的时候)。
这是由库内部的机制实现的,能够确保不发生内存泄漏,即使在有问题的浏览器下运行也能这样,比如……IE 6。



3.闭包
一个内部函数使用了外部（封闭）函数的变量。
var a=null
var b=function(){
    var c=a;
    var d=function(){
        if(c){}
    }
    a={
        e:new Array(100000).join('*'),
        f: function(){}
    }
}
setInterval(b,1000)
这段代码做了一件事:
每次调用 b 的时候,
a都会得到一个包含一个大数组和一个新闭包(f)的新对象。
同时,变量d指向一个引用了```c``的闭包。

一旦具有相同父作用域的多个闭包的作用域被创建,则这个作用域就可以被共享。
由于 f 共享了 d 闭包的作用域,
那么 d 引用包含的 c 会迫使它保持活动状态(两个闭包之间的整个共享作用域)。
这阻止了它被收集。


4.脱离DOM的引用
将DOM节点存储在数据结构中可能会很有用。
如果在将来的某个时候你决定删除这些行,那么你需要将引用都设置为不可访问。
var elements={
    btn:document.getElementById(''),
    img:document.getElementById('')
}
function removeImg(){}
如果removeImg只是rmoveChild元素img，
那么btn元素仍然在内存中，GC无法收集；

某些异步操作可能发生在事件循环的一个标记期间，
不会导致一个全新的事件被添加到事件循环队列中，
而是将一个项目(即任务)添加到当前标记的任务队列的末尾。


确定某个值是否是一个实际的Promise？
Promise 是由new Promise(…)语法构造的，
你可能认为``` p instanceof Promise``是一个足够可以判断的类型？
嗯,不完全是。
因为可以从另一个浏览器窗口(例如iframe)接收 Promise 值，
而该窗口或框架具有自己的 Promise 值，与当前窗口或框架中的 Promise 值不同，
所以该检查将无法识别 Promise 实例。
此外，库或框架可以选择性的封装自己的 Promise，而不使用原生 ES6 的Promise 来实现。

如果在 Promise 创建中，出现了一个javascript一场错误(TypeError 或者 ReferenceError)，
这个异常会被捕捉，并且使这个 promise 被拒绝。
但是，如果在调用 then(…) 方法中出现了 JS 异常错误，
p.then(…) 调用本身返回另一个 Promise，该 Promise 将被 TypeError 异常拒绝。

Promise 对象的回调链，不管以 then 方法或 catch 方法结尾，
要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。
一个常见的建议是，Promise 应该添加一个 done(…)，这实际上是将 Promise 链标记为 “done”。
因此，我们可以提供一个 done 方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。


ES8中改进了什么 ?Async/await （异步/等待）
使用 async 声明异步函数。这个函数返回一个 AsyncFunction 对象。
AsyncFunction 对象表示该函数中包含的代码的异步函数。

调用使用 async 声明函数时，它返回一个 Promise。
当这个函数返回一个值时，这个值只是一个普通值而已，
这个函数内部将自动创建一个承诺，并使用函数返回的值进行解析。

function getNumber1() {
    return Promise.resolve('374');
}
// 这个函数与getNumber1相同
async function getNumber2() {
    return 374;
}

类似地，抛出异常的函数等价于返回被拒绝的 Promise 的函数:
function f1() {
    return Promise.reject('Some error');
}
async function f2() {
    throw 'Some error';
}

如果在 async 函数之外使用 Promise，仍然需要使用 then 回调:
async function loadData(){}
// 因为不再处于异步函数中，必须使用then：
loadData().then()


编写高度可维护性、非易碎异步代码的5个技巧
1、简介代码: 使用 async/await 可以编写更少的代码。
// `rp` is a request-promise function.
var response = await rp(‘https://api.example.com/endpoint1');

2、错误处理: Async/wait 可以使用相同的代码结构(众所周知的try/catch语句)处理同步和异步错误。
async function loadData() {
    try {
        var data = JSON.parse(await getJSON());
        console.log(data);
    } catch(e) {
        console.log(e);
    }
}

3、条件:用async/ wait编写条件代码要简单得多:
async function loadData() {
  var response = await getJSON();
  if (response.needsAnotherRequest) {
    var anotherResponse = await makeAnotherRequest(response);
    console.log(anotherResponse)
    return anotherResponse
  }
}

4、堆栈帧:
async function loadData() {
  await callAPromise1()
  await callAPromise2()
  await callAPromise3()
  await callAPromise4()
  await callAPromise5()
  throw new Error("boom");
}
loadData()
  .catch(function(e) {
    console.log(err);
    // output
    // Error: boom at loadData (index.js:7:9)
});

5.调试:如果你使用过 Promise ，那么你知道调试它们是一场噩梦。
使用async/wait，您可以逐步完成wait调用，就像它们是正常的同步函数一样。







深入探索 websocket 和HTTP/2与SSE +如何选择正确的路径 
让服务器能够“主动”向客户机发送数据的技术已经出现了相当长的时间。例如“Push”和“Comet”。
WebSocket 规范定义了在 web 浏览器和服务器之间建立“套接字”连接的 API。

客户端通过 WebSocket 握手 过程建立 WebSocket 连接。
WebSocket url使用 ws 方案。还有 wss 用于安全的 WebSocket 连接，相当于HTTPS。
ws 是未加密的，默认端口为80，而 wss 需要TLS加密，默认端口为 443。

这个过程从客户机向服务器发送一个常规 HTTP 请求开始，这个请求中包含一个升级头，
它通知服务器客户机希望建立一个 WebSocket 连接。
var socket = new WebSocket('ws://websocket.example.com')
socket.onopen = function(event) {
  console.log('WebSocket is connected.');
};
请求头示例：
GET ws://websocket.example.com/ HTTP/1.1
Origin: http://example.com
Connection: Upgrade
Host: websocket.example.com
Upgrade: websocket
如果服务器支持 WebSocke t协议，它将同意升级，并通过响应中的升级头进行通信。
响应头示例：
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
一旦建立连接，open 事件将在客户端 WebSocket 实例上被触发:
初始 HTTP 连接被使用相同底层 TCP/IP 连接的 WebSocket 连接替换。
WebSocket url 的特殊之处在于它们不支持锚点.


消息分片
可以将字符串“Hello World”发送到11个包中，每个包的长度为6(报头长度)+ 1字节。
分片目的是发送长度未知的消息。
如果不分片发送，即一帧，就需要缓存整个消息，计算其长度，构建frame并发送；
使用分片的话，可使用一个大小合适的buffer，用消息内容填充buffer，填满即发送出去。

什么是跳动检测？
目的是保障客户端 websocket 与服务端连接状态
如果设备网络断开，不会触发任何函数，前端程序无法得知当前连接已经断开。
这个时候如果调用 websocket.send 方法，浏览器就会发现消息发不出去，
便会立刻或者一定短时间后触发 onclose 函数。
后端 websocket 服务也可能出现异常，连接断开后前端也并没有收到通知，
因此需要前端定时发送心跳消息 ping，后端收到 ping 类型的消息，
立马返回 pong 消息，告知前端连接正常。
如果一定时间没收到pong消息，就说明连接不正常，前端便会执行重连。

通过监听 error 事件来处理所有错误,
要关闭连接，客户机或服务器都应该发送包含操作码0x8的数据的控制帧。
当接收到这样一个帧时，
if (socket.readyState === WebSocket.OPEN) {
    // 关闭连接后接收到的任何其他数据都将被丢弃
    socket.close();
}



HTTP/2 是意在提升数据在线路上传输的效率。
HTTP/2引入了 Server Push，它使服务器能够主动地将资源发送到客户机缓存。
但是，它不允许将数据下推到客户机应用程序本身，
这意味着应用程序没有API来获取这些事件的通知。

如何选择WebSocket和HTTP/2?
一般情况下，只要需要客户端和服务器之间的真正低延迟，接近实时的连接，就使用 WebSocket,
建立一个大型多人在线游戏，需要来自连接两端的大量消息。
需要显示实时的市场消息，市场数据，聊天应用程序等，依靠 HTTP/2 + SSE.
当考虑到与现有 Web 基础设施的兼容性时，WebSocket 通常会变成一个痛苦的源头，
因为它将 HTTP 连接升级到完全不同于 HTTP 的协议。
Web 组件（防火墙，入侵检测，负载均衡）是以 HTTP 为基础构建，维护和配置的，
安全性和可伸缩性方面更偏向的环境。