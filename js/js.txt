高级语言：人类易于理解的语言，简单、抽象、方便读写，执行效率差、需要编译；
低级语言：控制硬件的行为，机器语言，执行速度快、难编写、易出错、兼容性差；

高级语言-》js、java、ruby-》go-》c++、rust-》assembier汇编-》机器语言

js=C语言的基本语法+java数据类型和内存管理+scheme函数式编程+self原型继承；

js动态类型语言，js无法在运行前无法编译成机器代码，
JIT运行时编译：js引擎

常用js引擎：
chrome的V8引擎、
webkit的JavascriptCore、
火狐的SpiderMonkey、
QuickJS、
Facebook在RN使用的Hermes、

js代码解析成抽象语法树ast，
再通过解析器将ast编译成字节码bytecode，
字节码和平台无关，能够在不同操作系统运行，
编译器根据不同平台把字节码编译成相应平台的机器代码；


V8引擎:
接收js代码、编译代码然后执行的C++程序，
编译后的代码可以在多种操作系统多种处理器上运行；
处理调用栈、内存分配、垃圾回收；

编译和执行js代码的组件：
解析器-将js源代码解析成ast
解释器-将ast解析成bytecode字节码（解释器也有直接解释执行bytecode的能力）
编译器-将字节码编译出运行更加高效的机器代码

V8早期5.9版本之前，没有解释器，却有两个编译器，流程如下：
js代码经解释器生成ast，
再由Full-codegen编译器（基准编译器）将ast编译出未被优化的机器代码，而不进行中间转换，
好处是第一次执行js时，就直接使用了高效的机器代码；
当代码运行一段时间后，V8引擎的分析器线程收集到足够的数据来帮助另一个编译器
Crankshaft（优化编译器）来做代码优化，
把需要优化的源码重新解析成ast，再生成优化后的机器代码，来提升运行的一个效率；
带来的问题：
机器码占用大量内存
缺少中间层字节码，无法实现一些优化策略
无法很好支持和优化js新语法特性

新架构设计：
js源代码通过解析器parser生成ast，
ast经基准解释器igniton生成bytecode字节码，此时ast就被清除掉了，释放内存空间；
解释器执行bytecode，
边执行边收集类型信息，
通过优化编译器TruboFan编译出优化后的机器代码；

优化策略：
函数只是声明而没有被调用，则该函数不会解析成ast，也就不会生成字节码；
函数只被调用一次，则ignition生成字节码后就直接被解释执行了，Turbofan不会进行优化编译，
因为需要ignition函数收集执行时的类型信息，这就要求函数至少执行大于一次，才能进行优化；
函数被调用多次可能被识别为热点函数，当ignition编译器收集的类型信息确定后，
TurboFan会将bytecode编译为优化后的机器代码，之后执行这个函数时，就直接运行优化后的机器代码；
有时优化后的机器代码会被逆向编程字节码，即deoptimization过程，然后由解释器执行字节码，
因为js是动态语言，导致ignition收集到的信息是错误的，
所以不要把一个变量的类型变来变去；

字节码生成速度远远大于机器码，所以网页初始化解析执行js的时间缩短了，网页可以更快onload；
直接从字节码生成优化机器代码，回退时也是直接回到字节码后进行执行；
