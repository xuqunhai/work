如何将文本解析为对机器有意义的内容
将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。

AST 不仅以结构化的方式显示源代码，
而且在语义分析中扮演着重要角色。
在语义分析中，编译器验证程序和语言元素的语法使用是否正确。
之后，使用 AST 来生成实际的字节码或者机器码。

进行静态代码分析
找到公共代码结构，以便你可以重构它们以减少重复。
Esprima 和 Acorn 即是黄金搭档,
ASTs 被广泛应用于代码转换。

实现一个将 Python 代码转换为J avaScript 的转换器。
基本思想是使用Python 转换器生成 AST，然后使用 AST 生成JavaScript代码。

https://astexplorer.net/
https://github.com/danielmendel/DeviceTiming

脚本流即脚本一旦开始下载，async 和 deferred的 脚本就会在单独的线程上解析。这意味着在下载脚本完成后几乎立即完成解析，这会提升 10% 的页面加载速度。
当用户返回同一页面时，诸如下载，解析和编译等所有步骤都会被跳过。 这使得 Chrome 可以节省大约 40％ 的解析和编译时间。 此外，这还可以节省移动设备的电量。

立即解析会运行需要立即编译的函数。它主要做三件事:
构建 AST，构建作用域层级和查找所有语法错误。

懒解析只运行未编译的函数。
它不构建AST，也不查找所有语法错误，
它只构建作用域层级，
与立即解析相比节省了大约一半的时间。

解析器看到 bar 函数的声明、baz 函数的声明、bar函数的调用和 console.log 的调用。
但是，解析器做了一些完全无关的额外工作即解析 bar 函数。
因为函数 bar 从来没有被调用过(或者至少在那个时候没有)。
它不需要语法树，因为它还没有被处理。
另外，它不会从堆中分配内存，而堆通常会占用相当多的系统资源，

那么为什么解析器不都使用懒解析呢? 
如果懒解析某些代码，这些代码需要立即执行，
这实际上会使代码运行速度变慢。
需要运行一次懒解析之后进行另一个立即解析，
这和立即解析相比，运行速度会慢 50%。

如何提高解析器的解析速度。
大多数解析器都能识别一种模式:使用括号封装函数。
如果解析器看到一个左括号，紧接着是一个函数声明，它将立即解析这个函数。
可以通过显式地声明立即执行的函数来帮助解析器加快解析速度。

假设有一个名为 foo 的函数。

function foo(x) {
    return x * 10;
}
因为没有明显地标识表明需要立即运行该函数所以浏览器会进行懒解析。

以上事例解析器执行懒解析，可以用括号封装起来，让解析器进行立即解析：
var foo = (function foo(x) {
    return x * 10;
});
解析器看见 function 关键字前的左括号便会立即进行解析。
这里有使用函数的名称 foo,这不是必需的，
但是建议这样做，
因为在抛出异常的情况下，stacktrace 会保留实际函数名称，而不仅仅是 <anonymous>。


这种地让代码更难阅读和理解。可以使用 Optimize.js 可以帮我们做这类事情，
该工具只是用来优化 JavaScript 源代码的初始加载时间，
它们对代码进行静态分析，
然后通过使用括号封装需要立即运行的函数以便浏览器立即解析并准备运行它们。
(function() {
    console.log('Hello, World!');
})();
在进入生产环境之前需要进行代码压缩，以下为压缩工具的输出：
!function(){console.log('Hello, World!')}();
压缩工具删除包裹函数的括号，而是在函数前放置了一个感叹号，
为了能够执行该函数，它将在懒解析之后立即进行立即解析。 这会使代码运行得更慢

幸运的是，可以利用 Optimize.js 来解决此类问题，传给 Optimize.js 压缩过的代码会输出如下代码：
!(function(){console.log('Hello, World!')})();