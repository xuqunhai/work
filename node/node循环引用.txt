当循环调用 require() 时，一个模块可能在未完成执行时被返回。比如：

a.js 的代码为：

console.log('a 开始'); // 此时exports对象为空对象{ }
exports.done = false; // 此时exports对象为 {done: false}
var b = require('./b.js');
console.log('在 a 中，b.done = %j', b.done);
exports.done = true;
console.log('a 结束');


b.js 的代码为：

console.log('b 开始');
exports.done = false;
var a = require('./a.js'); // 这里拿到的a是a文件中require之前的exports对象，即{done: false}
console.log('在 b 中，a.done = %j', a.done);
exports.done = true;
console.log('b 结束');


main.js 的代码为：

console.log('main 开始');
var a = require('./a.js');
var b = require('./b.js');
console.log('在 main 中，a.done=%j，b.done=%j', a.done, b.done);

当 main.js 加载 a.js 时，a.js 又加载 b.js。
此时，b.js 会尝试去加载 a.js。
为了防止无限的循环，会返回一个 a.js 的 exports 对象的未完成的副本给 b.js 模块。
然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。