互联网是如何运作的?
如何发送和接收数据？
访问某网站其实就是访问该网站的服务器；
电脑连接互联网，互联网就会分配给他一个ip地址，
通过TCP/IP协议族可将电子信号通过电缆发送给服务器，
服务器又把电子信号转换成计算机可使用的文本数据；

协议：网络通信的规则；
TCP/IP协议族共4层：
应用层 —— 应用程序协议：HTTP、FTP、IMAP；
TCP传输控制层 —— 发送数据包到指定端口 —— 面向连接的可靠字节流协议（三次握手、四次挥手），保证数据包到达和顺序正确；给数据包添加源端口和目的端口；
IP网络层 —— 使用IP将数据包发送到指定计算机 —— 数据包过大时会带序列号进行分包；给数据包添加源IP和目的IP；
链路层 —— 二进制数据包和网络信号之间转换，如把文本数据转成电子信号通过电缆传输；

IPv4只有2的32次方，约40亿个地址，导致不够用，所以出现IPv6；
IPv6是128位，所以有2的128次方个地址，在可预测的未来足够使用；

电脑通过调制解调器（猫），
猫将数据信号翻译成电话线能传送的模拟信号，
通过公共电话网络进行传输，
公共电话网络通过互联网服务器提供商ISP，如移动，来接入网络，
进而路由到互联网服务器的主干网络，
再经过多个路由器和多个主干网到达目的地；

网络服务提供商NSP是为互联网服务器提供商提供网络主干服务的公司；
ISP可从NSP那里批量购入带宽，为客户提供网络接入服务；
NSP通过网络访问点NAP相连来交换数据包流量；

如何把数据包送到目的地？
路由器——上面有个路由表，记录其子网络所有IP地址，
路由器检查路由表是否有目的地IP地址，有就直接发送给那个网络，
没有就向上层发送数据，在更高的层级去寻找拥有该IP地址的路由器；

DNS：域名和IP地址的对饮关系；

接收到数据后浏览器如何展示？浏览器原理。

浏览器结构：
用户界面 —— 除标签页窗口外的其他用户界面
浏览器引擎 —— 用户界面和渲染引擎之间传递数据，可操作数据持久层
渲染引擎（浏览器内核） —— 渲染页面内容
js解析器、网络模块、UI组件元素

浏览器内核：
IE： Trident
Firefox： Gecko
Safari： webkit
Chrome、Opera、Edge：Blink

浏览器是运行在操作系统的一个应用程序，
会启动至少一个进程来执行任务代码，并为该进程分配内存空间，保存程序状态，程序关闭时，内存空间会被回收，内存空间独立，进程间数据需要通过通信管道IPC传递；
进程可将任务分成多个小任务，并创建多个线程来并行执行，同一进程下的1线程之间数据共享；

单进程结构缺点：
不稳定，一个线程卡死可能导致整个进程出问题；
不安全，线程之间可共享数据，js线程随意访问进程内数据？
不流畅，一个进程负责太多事情，导致运行效率问题；

多进程浏览器结构：
浏览器进程
GPU进程
渲染器进程
（默认访问不同站点和同一站点不同页面都会创建新进程）
（占用更多内存空间，但最安全而且互相隔离互不影响，一个卡死并不会影响其他标签）
网络进程
缓存进程
插件进程


浏览器渲染原理
在浏览器地址栏输入内容时，浏览器内部发生了什么？
浏览器进程的UI线程捕捉你输入内容，
如果是网址，UI线程会启动一个网络线程请求DNS进行域名解析，接着开始连接服务器获取数据；
输入的是一串关键字时会使用默认配置的搜索引擎查询；

当网络现场获取到数据后，会通过SafeBrowsing（如查看站点ip是否在黑名单内）检测站点是否是恶意站点，
是则会展示警告页面并阻止你的访问；
否则通知UI线程，让UI线程创建一个渲染器进程来渲染页面，
浏览器进程通过IPC管道将数据传递给渲染器进程；

渲染器进程的主线程将html进行解析，构造DOM数据结构；
html首先经过Tokeniser标记化，通过词法分析，将html内容解析成多个标记，根据识别后的标记进行DOM树构造；
DOM树构造过程会创建Document对象；

html代码中的如图片、css资源通过网络下载或缓存中直接加载，
因为它们不会影响DOM生成，所以不会阻塞html解析；
但html解析过程遇到script标签，将停止html解析流程，转而去加载解析并执行js，
因为js执行可能会改变html结构，导致之前html解析没有任何意义；

html解析完后，主线程需要解析css并确定每个DOM节点的样式；
接着需要知道节点在页面的位置和节点自身大小，即layout布局；
layout树和最后展示在屏幕上的节点是对应的；

设置display为none的节点不会出现在layout tree上，
before伪类中添加content值的元素，content内容会出现在layout tree上，但不会出现在DOM树里；

知道了元素大小、形状和位置后，还需知道以什么样顺序绘制各个节点，
如z-index属性会影响节点绘制层级关系；
为了保证屏幕显示正确层级，在绘制阶段，
主线程遍历layout tree创建一个绘制记录表，记录绘制顺序；

栅格化：将信息转化成像素点显示在屏幕上。
composition组合：
将页面各个部分分成多个图层，分别对其进行栅格化并在合成器线程compositor thread的单独线程中进行合成页面的技术；
即对所有元素进行分图层并栅格化好，然后把可视区域内容组合成一帧展示给用户；



DOM tree + css
layout tree + 绘制顺序表
layer tree
合成器线程将图层切分，定优先级后给栅格线程处理
栅格线程按优先级处理栅格化
合成器收集已栅格的图块，生成合成器Frame，通过IPC发送浏览器进程
浏览器进程将Frame传到GPU
GPU渲染展示在屏幕上

重排、重绘和js都在主线程，就会出现抢占执行时间的问题，
如js执行时间过长导致下一帧开始时，js没有及时归还主线程，导致下一帧没有按时渲染，出现页面动画卡顿；
优化手段：
requestAnimationFrame这个api会在每一帧被调用，通过回调函数可知道每一帧还剩余的时间，
可以把js运行任务分成小块，在时间用完前归还主线程；
栅格化整个流程是不占用主线程的，只在合成器和栅格线程中运行，
css动画熟悉transform不会经过布局和绘制，直接运行在合成器和栅格线程中，
所以节省很多运算时间，让复杂动画更加流畅；