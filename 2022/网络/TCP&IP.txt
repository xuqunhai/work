全国各地朋友能正常通讯，是因为遵守共同TCP/IP协议族

对等层通讯
应用层     Date      应用层
传输层     Segement  传输层 端口
网络层     Packet    网络层 IP
数据链路层  Frame     数据链路层 MAC
物理层     Bit       物理层

报文封装（逐层）
应用层 应用层报头+数据
传输层 传输层报头+数据
网络层 网络层报头+传输层报头+数据
数据链路层 数据链路层报头+网络层报头+传输层报头+数据
物理层 1010111001010101

套接字socket=IP地址:端口号

IPv4报文
关键字段：协议（上层协议）、源IP地址、目标IP地址

网络层常见协议
ICMP协议
作用：
1、提供IP数据包处理情况的消息（传输过程发生错误、失败等）
2、提供网络诊断等

Ping是常用基于ICMP协议的工具，
1、测试源、目标主机间的IP连通性
2、显示从发送请求到收到应答的时间，衡量网络性能
默认发4-5个小的单播包，要求2s内收到应答
如果ping不通说明基础网络配置有问题，如果ping通而上层协议不通说明问题出在应用层程序上

数据链路层常见协议
局域网-以太网-Ehternet II帧格式-目的MAC、源MAC、类型（上层协议，如IP）、数据、帧检测序列
广域网-HDLC

网络设备对数据处理基于它所处的层次
传输层 防火墙
网络层 三层交换机、路由器 - 依据三层头部（IP）转发数据
数据链路层 二层交换机 - 依据二层头部（MAC）转发数据
物理层 中继器、HUB

TCP三次握手 Seq (Sequence序号) / SYN (synchronization同步)
client: SYN 序号1
server: ACK = 序号1 + 1, SYN 序号2
client: ACK = 序号2 + 1
如果黑客不断给server发SYN又不进行下一步，会让server记住序号1和生成序号2，挂起非常多资源，导致奔溃，这就是DDos攻击，
所以服务器干脆不保存序号，而是根据服务器IP和端口等私有信息进行算法的运算得到序号2

TLS1.2
TCP三次握手后
Client Hello（告诉服务器支持的TLS版本和加密套件，生成随机数1）
  （1） 支持的协议版本，比如TLS 1.0版。
  （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。
  （3） 支持的加密方法，比如RSA公钥加密。
  （4） 支持的压缩方法。
  不包括服务器的域名。
  也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。
  这就是为什么通常一台服务器只能有一张数字证书的原因。
  对于虚拟主机的用户来说，这当然很不方便。
  2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。
Server Hello（确定采取的TLS版本和加密套件，生成随机数2）
  （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
  （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。
  （3） 确认使用的加密方法，比如RSA公钥加密。
  （4） 服务器证书。
  如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。
  比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。
Certificate（服务器再次发请求出示自己的证书，浏览器可以对照自己证书新人列表确认服务器是否可信）
Server Key Exchange（发送公钥、证书给客户端）
Server Hello Done（服务器发送完毕）
Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message
（客户端生成随机数3并用公钥加密）（告诉服务器后面数据就用商量好的算法和密钥加密，即用随机数1和随机数2和随机数3生成会话密钥）（TSL协商没问题，加密开始）
    验证服务器证书。
    如果证书没有问题，客户端就会从证书中取出服务器的公钥。服务器公钥放在服务器的数字证书之中。
  （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
  （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
  （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
Application Data（后面数据使用会话密钥加解密）
New Session Ticket（服务器拿到加密后的随机数3，用私钥解密得到随机数3）
Change Cipher Spec（服务器也用随机数1和随机数2和随机数3生成会话密钥）
  客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。
Encrypted Handshake Message（服务器回应TSL协商没问题）
Application Data（后面数据使用会话密钥加解密）
  （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
  （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。
服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。
这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。

握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。
这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。
  session ID的思想很简单，就是每一次对话都有一个编号（session ID）。
  如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。
  缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。
  session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。
  发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密


TCP四次挥手
客户端或服务器都能主动发起，在发送http请求和响应时候序号和确认号被不断递增
客户端发起FIN+ACK（序号+确认号）
服务器ACK （自己序号用对方确认号，自己确认号用对方序号+1）
此时客户端并未正式关闭通道，因为服务器可能还有需要发送的数据（这就是为什么需要4次而不是2次）
等服务器发送完数据后，会发送一个 FIN+ACK 来最终确认，此时序号和确认号不需要改变，因为没有一来一回，只是多了一个FIN来确认结束步骤；
客户端得到最终结束确认后发送ACK进行确认（自己序号用对方确认号，自己确认号用对方序号+1）