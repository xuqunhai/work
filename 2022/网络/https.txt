HTTP 协议的历史演变
主要规定了客户端和服务器之间的通信格式，默认使用80端口。

最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。
GET /index.html
协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。
服务器发送完毕，就关闭TCP连接。

1996年5月，HTTP/1.0 版本发布
首先，任何格式的内容都可以发送。
除了GET命令，还引入了POST命令和HEAD命令
HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
新增功能还包括
状态码（status code）、
多字符集支持、
多部分发送（multi-part type）、
权限（authorization）、
缓存（cache）、
内容编码（content encoding）等。

第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
回应的格式是"头信息 + 一个空行（\r\n） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。
HTTP/1.0 200 OK 

2.4 Content-Type 字段
1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。
值为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。MIME type还可以在尾部使用分号，添加参数。
Content-Type: text/html; charset=utf-8
发送的是网页，而且编码是UTF-8。
客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。
Accept: */*
MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<!-- 等同于 -->
<meta charset="utf-8" /> 

2.5 Content-Encoding 字段
由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。
客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。
Accept-Encoding: gzip, deflate

HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。
TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。
随着网页加载的外部资源越来越多，这个问题就愈发突出了。

1997年1月，HTTP/1.1 版本发布
引入了持久连接（persistent connection），
  即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。
  客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。
  对于同一个域名，大多数浏览器允许同时建立6个持久连接。
引入了管道机制（pipelining），
  即在同一个TCP连接里面，客户端可以同时发送多个请求。
  管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。
Content-Length 字段
  TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用
  Content-Length: 3495 上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。
  在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。
分块传输编码
  使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。
  对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。
  1.1版规定可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。
  只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。
  Transfer-Encoding: chunked
  每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。
    -----
    HTTP/1.1 200 OK
    Content-Type: text/plain
    Transfer-Encoding: chunked

    25
    This is the data in the first chunk

    1C
    and this is the second one

    3
    con

    8
    sequence

    0

    -----
1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。
客户端请求的头信息新增了Host字段，用来指定服务器的域名。可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。

1.1版缺点
"队头堵塞"（Head-of-line blocking）
同一个TCP连接里面，所有的数据通信是按次序进行的。通过串行传输的，多个请求之间的响应可能会被阻塞。
服务器只有处理完一个回应，才会进行下一个回应。
要是前面的回应特别慢，后面就会有许多请求排队等着。
为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。
导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。

SPDY是一种基于HTTP的兼容协议，由Google发起，
SPDY传输支持多路复用和服务器推送技术，压缩了HTTP头部减小了请求大小，并强制使用SSL传输协议，
到目前为止已经成为了一套成熟的高效协议标准。
但由于SPDY必须使用HTTPS协议，所以之前HTTP的网站就无法直接使用SPDY，因此最终HTTP Working-Group决定以SPDY 2版本协议规范为基础

2015年，HTTP/2 发布
目前支持HTTP 2协议传输的浏览器依然很少，至少需要达到EDGE 13、Chrome 45或Safari 9.2以上版本。
5.1 二进制协议
  头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。
  HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。
  二进制在网络中传输的基本单位一般为帧（Frame，一个帧可以理解为具有固定格式和长度的二进制数据包），
  每个帧包含几个固定部分内容：类型Type、长度Length、标记Flags、流标识Stream和Frame payload（帧有效载荷，一帧能携带的内容数据长度）。
  多个帧的传输在网络中就形成了帧的传输网络流，所以我们也可以理解为HTTP 2协议是通过流式传输的。
5.2 多工
  复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。
  在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，
  于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。
  TCP连接复用和HTTP 1.1中keep-alive连接复用的区别：
  TCP复用传输是发生在传输层的，而keep-alive控制的文件的连接复用是在应用层的；
  keep-alive的连接复用是串行的，即一个文件传输完后，下个文件才能复用这个连接，
  而TCP复用是帧的多路复用，即不同文件的传输帧可以在一个TCP连接中一起同时进行流式传输。
5.3 数据流
  HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
  HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。
  每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。
  HTTP 2支持传输流的优先级和流量控制机制。
  使用HTTP 2的情况下CSS文件就不一定要写在HTML的顶部，JavaScript也不一定要在HTML最底部写了，因为HTTP 2的服务器自动就能帮你做这件事情。
  客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。
  数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。
  1.1版取消数据流的唯一方法，就是关闭TCP连接。HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。
5.4 头信息压缩
  HTTP 协议不带有状态，每次请求都必须附上所有信息。
  比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。
  HTTP/2 对这一点做了优化，采用HPACK压缩传输
  一方面，头信息使用gzip或compress压缩后再发送；
  另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号
5.5 服务器推送
  允许服务器未经请求，主动向客户端发送资源
  正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。
  其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

------------------------------------------------------------------------

HTTP明文
（1） 所有信息都是加密传播，第三方无法窃听。
加密-让数据不那么容易被识破-加密算法（AES、3DES）E就是Encryption加密；
（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。
保护数据完整性用Hash（使用算法MD5、SHA1SHA-256根据一段字符串生成一个唯一Hash值），接收方根据Hash判断数据有没被篡改；
（3） 配备身份证书，防止身份被冒充。
认证对方是不是冒充，算法（PSK、RSA）；

如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

------------------------------------------------------------------------

服务器需要申请SSL证书，证明这个域名
SSL证书是TLS证书前身
SSL证书是保存着源服务器的数据文件
包括 签发者】过期时间、版本、签名算法、公钥私钥

------------------------------------------------------------------------
加密算法套件 CipherSuite
Cipher泛指是密码学的加密算法，例如 aes, rsa, ecdh 等。
Authentication 认证算法；
Encryption 对称加密算法；
Message Authentication Code 消息认证码算法；
Key Exchange 密钥交换算法。

------------------------------------------------------------------------

HTTPS单向认证
客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;
服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;
客户端使用服务端返回的信息验证服务器的合法性，包括：
证书是否过期;
发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)
返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）
服务器证书上的域名是否和服务器的实际域名相匹配;
验证通过后，将继续进行通信，否则，终止通信;
客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择;

服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;
服务器将选择好的加密方案通过明文方式返回给客户端;
客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器;
服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥;
在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全;


HTTPS双向认证
双向认证和单向认证类似，它额外增加了服务端对客户端的认证：
客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;
服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;
客户端使用服务端返回的信息验证服务器的合法性，包括：
证书是否过期;
发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)
返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）
服务器证书上的域名是否和服务器的实际域名相匹配;
验证通过后，将继续进行通信，否则，终止通信;
服务端要求客户端发送客户端的证书即客户端证书公钥，客户端会将自己的证书发送至服务端；

验证客户端的证书，通过验证后，会获得客户端的公钥；
客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择
服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;
将加密方案通过使用之前获取到的公钥进行加密，返回给客户端
客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端；
服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全；


1. 客户端向一个需要https访问的网站发起请求。
2. 服务器将证书发送给客户端进行校验。证书里面包含了其公钥。这里要特别说一下客户端到底 如何来校验对方发过来的数字证书是否有效。
首先在本地电脑寻找是否有这个服务器证书上的ca机构的根证书。如果有继续下一步，如果没有弹出警告。
使用ca机构根证书的公钥对服务器证书的指纹和指纹算法进行解密。
得到指纹算法之后，拿着这个指纹算法对服务器证书的摘要进行计算得到指纹。
将计算出的指纹和从服务器证书中解密出的指纹对比看是否一样如果一样则通过认证。
3. 校验成功之后，客户端会生成一个随机串然后使用服务器证书的公钥进行加密之后发送给服务器。
4. 服务器通过使用自己的私钥解密得到这个随机值。
5. 服务器从此开始使用这个随机值进行对称加密开始和客户端进行通信。
6. 客户端拿到值用对称加密方式 使用随机值进行解密。

