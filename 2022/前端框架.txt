服务端渲染
通过模版引擎填充数据，返回生成的 html，交给浏览器渲染,表单会同步提交

ajax 技术，可以异步的请求，服务端返回 xml 或者 json
xml 多了很多没必要的标签，内容比较多，所以后来 json 流行开来。

网页和服务端的数据交互变成了异步的，可以服务端返回 json 数据，浏览器里拼接 html，之后渲染
页面基本没啥刷新的必要了，于是后来就逐渐演变出了单页应用 

为了简化 dom 操作和更方便的兼容各种浏览器，出现了 jquery 
拿到数据渲染 dom，并且数据改变之后更新 dom

 mvvm 框架，来自动把数据的变更映射到 dom，不再需要手动操作 dom。也就是 vue、react 等现代的前端框架
 还支持了 dom 的逻辑划分，可以把一部分 dom 封装成组件，组件和组件之间相互组合，构成整个界面
 主要解决的是数据到 dom 的绑定，可以变化以后自动更新 dom。
 如果不需要更新，那么直接操作 dom 即可，比如各种活动页，没啥数据更新，用 jquery 操作 dom 还是很方便。

 react 是给 js 扩展了 jsx 的语法，由 babel 实现，可以在描述视图的时候直接用 js 来写逻辑，没啥新语法。
 而 vue 是实现了一套 template 的 DSL，引入了插值、指令、过滤器等模版语法，相对于 jsx 来说更简洁，template 的编译器由 vue 实现。

 vue template 是受限制的，只能访问 data，prop、method，可以静态的分析和优化，
 而 react 的 jsx 因为直接是 js 的语法，动态逻辑比较多，没法静态的做分析和优化。

 vue template 也不全是好处，因为和 js 上下文割裂开来，引入 typescript 做类型推导的时候就比较困难，
 需要单独把所有 prop、method、data 的类型声明一遍才行。
 而 react 的 jsx 本来就是和 js 同一个上下文，结合 typescript 就很自然。

数据分散在每个组件中，怎么在数据变化以后更新 dom 呢？
vue 就是基于数据的 watch 的，组件级别通过 Object.defineProperty 监听对象属性的变化，重写数组的 api 监听数组元素的变化
angular 则是基于脏检查，在每个可能改变数据的逻辑之后都对比下数据是否变了
react 则是中间加了一层虚拟 dom，每次都渲染成这个虚拟 dom，然后 diff 下渲染出的虚拟 dom 是否变了

vue 是组件级别的数据 watch，当组件内部监听数据变化的地方特别多的时候，一次更新可能计算量特别大，计算量大了就可能会导致丢帧，也就是渲染的卡顿。
所以 vue 的优化方式就是把大组件拆成小组件，这样每个数据就不会有太多的 watcher 了。
react 并不监听数据的变化，而是渲染出整个虚拟 dom，然后 diff。
基于这种方案的优化方式就是对于不需要重新生成 vdom 的组件，通过 shouldComponentUpdate 来跳过渲染。
当应用的组件树特别大的时候，只是 shouldComponentUpdate 跳过部分组件渲染，依然可能计算量特别大。计算量大了同样可能导致渲染的卡顿，怎么办呢？
树的遍历有深度优先和广度优先两种方式，组件树的渲染就是深度优先的，一般是通过递归来做，
但是如果能通过链表记录下路径，就可以变成循环。组件树的链表化（fiber）来把递归改成可打断的渲染，按照时间片来逐渐生成整个 vdom。
这个通过把组件树改成链表，把 vdom 的生成从递归改循环的功能就是 react fiber。
fiber 节点相对于之前的组件节点来说，没有了 parent、children 这种属性，多了 child、sibling、return 属性。
通过 fiber 链表树，优化了渲染的性能。

逻辑的复用
vue2 的组件内逻辑复用方案就是 mixin，但是 mixin 很难区分混入的属性、方法的来源，比较乱，代码维护性差。但也没有更好的方案。
react 的组件是 class 和 function 两种形式，那么类似高阶函数的高阶组件（high order component）的方式就比较自然，
也就是组件套组件，在父组件里面执行一部分逻辑，然后渲染子组件。
没有逻辑的部分可以直接把那部分 jsx 作为 props 传入另一个组件来复用，也就是 render props。
但是 HOC 的逻辑复用方式最终导致了组件嵌套太深，而且 class 内部生命周期比较多，逻辑都放在一起导致了组件比较大。
 react 就在 function 组件的 fiber 节点中加入了 memorizedState 属性用来存储数据，然后在 function 组件里面通过 api 来使用这些数据，这些 api 被叫做 hooks api。
每个 hooks api 都要有自己存放数据的地方，怎么组织呢？有两种方案，一种是 map，一种是数组。
为了简化使用， hooks 最终使用了数组的方式。当然，实现起来用的是链表。

要解决的 class 组件嵌套过深和组件太大的问题，通过 hooks 都能解决：
逻辑扩展不需要嵌套 hoc 了，多调用一个自定义的 hooks 就行
组件的逻辑也不用都写在 class 里了，完全可以抽离成不同的 hooks

为了体验和原生更接近，现在基本都是不刷新页面的单页应用，都是从服务端取数据然后驱动 dom 变化的 浏览器渲染(csr)方案。
基于同一个组件树，把它渲染成字符串。服务端渲染和浏览器渲染都用同样的组件代码，这就是同构的方案。

其实物理层的东西一直都没变，只是逻辑层不断的一层添加又一层，目的都是为了提高生产效率，降低开发成本，保证质量，这也是技术发展的趋势。