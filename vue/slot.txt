组合组件

app.vue
<list :items="items">
    <item slot-scope="{item}" :item="item"></item>
</list>

list.vue
<div v-for="item in visibleData" :key="item.id">
    <slot :item="item"></slot>
</dov>
props: {
    items: Object
}
computed: {
    visibleData() {
        return this.items
    }
}

item.vue
props: {
    item: Object
}

slot原理解析
{
    bind(){
        // 根据name获取将要替换插槽的元素
        var name = this.params.name
        // this.vm._slotContents 父模版中子组件的模版内容按照slot值组成的键值对。没有slot属性的将放入default值中
        var content = this.vm._slotContents && this.vm._slotContents[name]
        if(!content || !content.hasChildNodes()){
            this.fallback()
        }else{
            this.compile(content.cloneNode(true),this.vm._context,this.vm)
        }
    },
    complie(content,context,host){
        if(content && context){
            if(this.el.hasChildNodes()&&
            content.childNodes.length===1&&
            content.childNodes[0].nodeType===1&&
            content.childNodes[0].hasAttribute('v-if')
        ){
            const elseBlock=document.createElement('template')
            elseBlock.setAttribute('v-else','')
            elseBlock.innerHTML=this.el.innerHTML
            elseBlock._context=this.vm
            content.appendChild(elseBlock)
        }
        const scope=host ? host._scope : this._scope
        this.unlink=context.$compile(content,host,scope,this._frag)
    },
    fallback(){
        this.compile(extractContent(this.el,true),this.vm)
    },
    unbind(){
        if(this.unlink){
            this.unlink()
        }
    }
}



slot分发内容：
混合父组件内容与子组件自己的模版，
编译作用域：
父组件模版的内容在父组件作用域内编译，子组件模版的内容在子组件作用域内编译，
所以<child v-show=“showFlag”>{{msg}}</child>这里msg和showFlag都应该绑定到父组件数据；
父组件内容将被抛弃，除非子组件模版包含slot；
slot内容视为回退内容，回退内容在子组件的作用域内编译；
匿名slot作为找不到匹配内容片段的回退插槽，没有默认slot，找不到匹配的内容片段将被抛弃；